'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _cliUtils = require('@tradie/cli-utils');

require('./log/types');

var _Collector = require('./log/Collector');

var _Collector2 = _interopRequireDefault(_Collector);

var _formatting = require('./log/formatting');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var Reporter = function () {

  /** @private */

  /**
   * The text printed when compilation has started
   * @private
   */

  /** @private */

  /** @private */

  /**
   * The timeout to determine if we're still running
   * @private
   */
  function Reporter() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Reporter);
    this.running = 0;
    this.runningTimeout = null;
    this.promise = null;
    this.resolve = null;
    this.reject = null;
    this.watch = false;
    this.logs = new _Collector2.default();
    this.events = {};
    var _options$watch = options.watch,
        watch = _options$watch === undefined ? false : _options$watch,
        context = options.context,
        _options$startedText = options.startedText,
        startedText = _options$startedText === undefined ? 'Starting' : _options$startedText,
        _options$finishedText = options.finishedText,
        finishedText = _options$finishedText === undefined ? 'Finished' : _options$finishedText;

    this.context = context;
    this.watch = watch;

    this.startedText = startedText;
    this.finishedText = finishedText;

    this.promise = new _promise2.default(function (resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
  }

  /** @private */

  /** @private */

  /**
   * The text printed when compilation has finished
   * @private
   */

  /** @private */

  /** @private */

  /** @private */

  /**
   * The number of compilations currently in progress
   * @private
   */

  (0, _createClass3.default)(Reporter, [{
    key: 'resolveOrReject',
    value: function resolveOrReject() {
      if (this.hasErrors() && this.reject) {
        this.reject();
      } else if (!this.hasErrors() && this.resolve) {
        this.resolve();
      }
    }

    /** @private */

  }, {
    key: 'printStartOfReport',
    value: function printStartOfReport() {
      (0, _cliUtils.clear)();
      console.log();
      console.log(`  ${this.startedText}...`);
      console.log();
    }

    /** @private */

  }, {
    key: 'printMessages',
    value: function printMessages(level) {
      console.log((0, _formatting.formatLogs)(this.logs.filter(function (log) {
        return log.level === level;
      }), {
        cwd: this.context
      }));
    }

    /** @private */

  }, {
    key: 'printEndOfReport',
    value: function printEndOfReport() {
      (0, _cliUtils.clear)();
      console.log();
      this.printMessages('info');
      if (this.hasErrors()) {
        this.printMessages('error');
        console.log(_chalk2.default.red(_chalk2.default.bold(`  ❌  ${this.finishedText} with errors`)));
      } else if (this.hasWarnings()) {
        this.printMessages('warn');
        console.log(_chalk2.default.yellow(_chalk2.default.bold(`  ⚠️  ${this.finishedText} with warnings`)));
      } else {
        console.log(_chalk2.default.green(`  ✅  ${this.finishedText} successfully.`));
      }
      console.log();

      return this;
    }

    /** @private */

  }, {
    key: 'trigger',
    value: function trigger(type) {
      if (!this.events[type]) {
        return _promise2.default.resolve();
      }
      return _promise2.default.all(this.events[type].map(function (fn) {
        return fn();
      })).then(function () {});
    }
  }, {
    key: 'before',
    value: function before(event, fn) {
      var type = `before:${event}`;
      if (!this.events[type]) {
        this.events[type] = [];
      }
      this.events[type].push(fn);
      return this;
    }
  }, {
    key: 'after',
    value: function after(event, fn) {
      var type = `after:${event}`;
      if (!this.events[type]) {
        this.events[type] = [];
      }
      this.events[type].push(fn);
      return this;
    }
  }, {
    key: 'hasInfo',
    value: function hasInfo() {
      return this.logs.filter(function (log) {
        return log.level === 'info';
      }).length > 0;
    }
  }, {
    key: 'hasWarnings',
    value: function hasWarnings() {
      return this.logs.filter(function (log) {
        return log.level === 'warn';
      }).length > 0;
    }
  }, {
    key: 'hasErrors',
    value: function hasErrors() {
      return this.logs.filter(function (log) {
        return log.level === 'error';
      }).length > 0;
    }
  }, {
    key: 'log',
    value: function log(record) {
      this.logs.log(record);
      return this;
    }
  }, {
    key: 'info',
    value: function info(data) {
      this.logs.info(data);
      return this;
    }
  }, {
    key: 'warning',
    value: function warning(data) {
      this.logs.warn(data);
      return this;
    }
  }, {
    key: 'error',
    value: function error(data) {
      this.logs.error(data);
      return this;
    }

    /**
     * Notify the reporter that a compilation has started
     */

  }, {
    key: 'start',
    value: function start() {
      ++this.running;

      //if this is the first compilation running, and we're not waiting for other compilations to start then
      if (this.running === 1 && !this.runningTimeout) {
        //clear the logs
        this.logs.clear();

        //print the start of the report
        this.printStartOfReport();
      }

      //clear the running timeout
      clearTimeout(this.runningTimeout);
      this.runningTimeout = null;

      return this;
    }

    /**
     * Notify the reporter that a compilation has finished
     */

  }, {
    key: 'finish',
    value: function finish() {
      var _this2 = this;

      --this.running;

      //if this is the only compilation running, then we'll wait to see if another compilation starts soon so we don't print
      // a million success messages
      if (this.running === 0) {
        this.runningTimeout = setTimeout((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
          return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:

                  //clear the running timeout
                  clearTimeout(_this2.runningTimeout);
                  _this2.runningTimeout = null;

                  //wait for any running compilations to finish

                  if (!(_this2.running || _this2.runningTimeout)) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt('return');

                case 4:
                  _context.prev = 4;
                  _context.next = 7;
                  return _this2.trigger('before:finished');

                case 7:
                  _context.next = 12;
                  break;

                case 9:
                  _context.prev = 9;
                  _context.t0 = _context['catch'](4);

                  _this2.errored(_context.t0);

                case 12:
                  if (!(_this2.running || _this2.runningTimeout)) {
                    _context.next = 14;
                    break;
                  }

                  return _context.abrupt('return');

                case 14:

                  //print the end of the report
                  _this2.printEndOfReport();

                  //let the caller do stuff after the report is printed
                  _context.prev = 15;
                  _context.next = 18;
                  return _this2.trigger('after:finished');

                case 18:
                  _context.next = 23;
                  break;

                case 20:
                  _context.prev = 20;
                  _context.t1 = _context['catch'](15);

                  _this2.errored(_context.t1);

                case 23:

                  //if we're not watching and all the compilations have finished, then resolve or reject
                  if (!_this2.watch && !_this2.running && !_this2.runningTimeout) {
                    _this2.resolveOrReject();
                  }

                case 24:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, _this2, [[4, 9], [15, 20]]);
        })), 100);
      }

      return this;
    }

    /**
     * A fatal error occurred. Stop immedietly.
     * @param {Error} error
     */

  }, {
    key: 'errored',
    value: function errored(error) {
      if (this.reject) this.reject(error);
      return this;
    }

    /**
     * Notify the reporter that the compilation is stopping now, or at the end of the current compilation
     */

  }, {
    key: 'stop',
    value: function stop() {
      //if there are no running compilations, then resolve or reject now (watching has already stopped)
      if (!this.running && !this.runningTimeout) {
        this.resolveOrReject();
      } else {
        this.watch = false;
      }
      return this;
    }

    /**
     * Wait until all the running compilations have stopped and we're no longer watching
     */

  }, {
    key: 'wait',
    value: function wait() {
      //if we're not watching and there are no running compilations, then resolve or reject now
      if (!this.watch && !this.running && !this.runningTimeout) {
        this.resolveOrReject();
      }
      return this.promise;
    }
  }]);
  return Reporter;
}();
/* eslint-disable no-console */

exports.default = Reporter;